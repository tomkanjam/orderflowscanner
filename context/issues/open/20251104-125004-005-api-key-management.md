# Secure API Key Management

**Type:** feature
**Initiative:** End-to-end trader workflow implementation
**Created:** 2025-11-04 12:50:04

## Context

Implement secure storage and encryption for users' Binance API keys. Keys must be encrypted at rest and only decrypted on-demand in Edge Functions, never in logs or frontend.

**Security critical:** API key leakage could allow theft of user funds.

## Linked Items

- Part of: `context/issues/open/20251104-125004-000-PROJECT-trade-execution-infrastructure.md`
- Blocks: `context/issues/open/20251104-125004-003-order-execution-engine.md`

## Progress

**Status:** Not started

## Spec

### Database Schema

```sql
CREATE TABLE user_api_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),

  -- Encrypted keys (AES-256)
  encrypted_api_key TEXT NOT NULL,
  encrypted_secret TEXT NOT NULL,
  encryption_iv TEXT NOT NULL, -- Initialization vector

  -- Metadata
  label VARCHAR(100), -- User-friendly name
  exchange VARCHAR(20) DEFAULT 'binance',
  permissions JSONB, -- READ_ONLY, SPOT_TRADE, etc.

  -- Validation
  is_validated BOOLEAN DEFAULT false,
  last_validated_at TIMESTAMPTZ,
  validation_error TEXT,

  -- Usage tracking
  last_used_at TIMESTAMPTZ,
  use_count INT DEFAULT 0,

  -- Safety
  is_active BOOLEAN DEFAULT true,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_user_api_keys_user ON user_api_keys(user_id)
  WHERE is_active = true;

-- RLS
ALTER TABLE user_api_keys ENABLE ROW LEVEL SECURITY;

CREATE POLICY api_keys_select_own ON user_api_keys FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY api_keys_insert_own ON user_api_keys FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY api_keys_update_own ON user_api_keys FOR UPDATE
  USING (auth.uid() = user_id);
```

### Encryption Strategy

**Use Supabase Vault (recommended):**
- Supabase provides `pgsodium` extension for encryption
- Encryption keys never leave database
- Automatic key rotation

**Implementation:**
```sql
-- Enable pgsodium
CREATE EXTENSION IF NOT EXISTS pgsodium;

-- Encrypt API key before storing
INSERT INTO user_api_keys (user_id, encrypted_api_key, encrypted_secret, encryption_iv)
VALUES (
  $1,
  pgsodium.crypto_aead_det_encrypt($2::bytea, $3::bytea, $4::uuid::text::bytea),
  pgsodium.crypto_aead_det_encrypt($3::bytea, $3::bytea, $4::uuid::text::bytea),
  gen_random_uuid()::text
);

-- Decrypt in Edge Function (service role only)
SELECT
  pgsodium.crypto_aead_det_decrypt(encrypted_api_key, encryption_key, encryption_iv)::text,
  pgsodium.crypto_aead_det_decrypt(encrypted_secret, encryption_key, encryption_iv)::text
FROM user_api_keys
WHERE user_id = $1 AND is_active = true;
```

### Edge Function: decrypt-api-keys

```typescript
// supabase/functions/decrypt-api-keys/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  try {
    // Verify service role (only Go backend can call this)
    const authHeader = req.headers.get('Authorization')
    if (!authHeader || !authHeader.includes(Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'))) {
      return new Response('Unauthorized', { status: 401 })
    }

    const { userId } = await req.json()

    // Create service role client
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    )

    // Decrypt keys using pgsodium
    const { data, error } = await supabase
      .rpc('decrypt_user_api_keys', { user_id: userId })

    if (error) throw error

    if (!data || data.length === 0) {
      return new Response(
        JSON.stringify({ error: 'No API keys found' }),
        { status: 404 }
      )
    }

    const keys = data[0]

    // Never log the keys
    console.log(`API keys decrypted for user ${userId}`)

    return new Response(
      JSON.stringify({
        apiKey: keys.api_key,
        secret: keys.secret
      }),
      { headers: { 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Decryption error:', error.message)
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500 }
    )
  }
})
```

### Database Function for Decryption

```sql
CREATE OR REPLACE FUNCTION decrypt_user_api_keys(user_id UUID)
RETURNS TABLE (
  api_key TEXT,
  secret TEXT
) SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY
  SELECT
    convert_from(
      pgsodium.crypto_aead_det_decrypt(
        decode(encrypted_api_key, 'base64'),
        decode(encryption_iv, 'base64'),
        user_id::text::bytea
      ),
      'UTF8'
    ) AS api_key,
    convert_from(
      pgsodium.crypto_aead_det_decrypt(
        decode(encrypted_secret, 'base64'),
        decode(encryption_iv, 'base64'),
        user_id::text::bytea
      ),
      'UTF8'
    ) AS secret
  FROM user_api_keys
  WHERE user_api_keys.user_id = decrypt_user_api_keys.user_id
    AND is_active = true
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Only service role can execute
REVOKE EXECUTE ON FUNCTION decrypt_user_api_keys FROM PUBLIC;
GRANT EXECUTE ON FUNCTION decrypt_user_api_keys TO service_role;
```

### API Key Validation

Edge Function to test keys before storing:

```typescript
// supabase/functions/validate-api-keys/index.ts
import ccxt from 'https://esm.sh/ccxt@4.1.0'

serve(async (req) => {
  const { apiKey, secret } = await req.json()

  try {
    const exchange = new ccxt.binance({
      apiKey,
      secret,
      options: { defaultType: 'spot' }
    })

    // Test keys by fetching balance
    const balance = await exchange.fetchBalance()

    // Check permissions
    const hasSpotTrade = exchange.has['createOrder']

    return new Response(
      JSON.stringify({
        valid: true,
        permissions: {
          read: true,
          trade: hasSpotTrade
        },
        balance: {
          total: balance.total.USDT || 0
        }
      })
    )

  } catch (error) {
    return new Response(
      JSON.stringify({
        valid: false,
        error: error.message
      }),
      { status: 400 }
    )
  }
})
```

### Frontend: API Key Input Form

```typescript
// Add to settings page
async function saveAPIKeys(apiKey: string, secret: string) {
  // 1. Validate keys
  const validateRes = await fetch('/functions/v1/validate-api-keys', {
    method: 'POST',
    body: JSON.stringify({ apiKey, secret })
  })

  const validation = await validateRes.json()
  if (!validation.valid) {
    throw new Error('Invalid API keys: ' + validation.error)
  }

  // 2. Encrypt and store (server-side via RPC)
  const { data, error } = await supabase.rpc('store_encrypted_api_keys', {
    api_key: apiKey,
    secret: secret,
    label: 'Binance Main Account'
  })

  if (error) throw error

  // 3. Clear from memory
  apiKey = ''
  secret = ''

  return data
}
```

### Security Checklist

- [ ] Keys encrypted at rest using AES-256
- [ ] Encryption keys stored in Supabase Vault, never in code
- [ ] Decryption only in Edge Function with service role
- [ ] Keys never logged (not even in errors)
- [ ] Keys never sent to frontend after storage
- [ ] API key validation before storing
- [ ] Permission check (ensure SPOT_TRADE enabled)
- [ ] Rate limiting on decryption endpoint
- [ ] Audit log of all key usage
- [ ] User can revoke keys at any time

### Success Criteria

- [ ] API keys stored encrypted in database
- [ ] Decryption Edge Function works
- [ ] Go backend can get decrypted keys
- [ ] Keys never appear in logs
- [ ] Validation prevents invalid keys
- [ ] Security audit passes
- [ ] No keys leaked in error messages

### Effort Estimate

**2-3 days**
