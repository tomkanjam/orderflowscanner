# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an AI-powered cryptocurrency screener for Binance Spot markets that allows users to describe technical trading conditions in natural language. The application uses LLM models to convert natural language into executable screening filters and visualizes results with real-time charts. Filters can be based on any standard or fully custom metric or indicator that can be calculated from Binance kline data. Top-tier users get access to fully automated AI trading with the use of LLM APIs.

The app is not yet in production. There are no produciton users but we want to launch in a week.

## Design Philosophy

**Mobile-first.** This is every trader's dream: build fully automated AI traders with natural language, manage them on the go, stay connected to markets anywhere. Design for thumb-first interactions on phones, scale up gracefully to tablets and desktops. 44px+ tap targets, vertical scrolling, progressive disclosure, instant feedback. Reference: `~/.claude/skills/design.md`

**shadcn/ui only.** MANDATORY: Use shadcn/ui components exclusively for ALL UI elements. NEVER create custom components. Use the shadcn MCP server to add components. This ensures professional, accessible, consistent design throughout the app.

## Current initiative
### End-to-end trader workflow implementation
1. Create trader
2. Correct, performant filter code is created
3. Signals are generated by filter code
4. Signal creation triggers AI analysis
5. Full Braintrust instrumentation - Tracing, evals, etc.
6. Entire worflow has top-tier UX and observabity in the frontend.


## Development Environment
Use pnpm
Use only production supabase and production fly environments. No local stuff!

### Environment Variables
Required for all environments:
- `BRAINTRUST_API_KEY` - Braintrust API authentication
- `BRAINTRUST_PROJECT_ID` - Braintrust project ID (5df22744-d29c-4b01-b18b-e3eccf2ddbba)
- `SUPABASE_URL` - Supabase project URL
- `SUPABASE_SERVICE_ROLE_KEY` - Supabase admin key
- `OPENROUTER_API_KEY` - OpenRouter API key for LLM calls

### Prompt Management Architecture

**Hybrid Approach: Git as Source of Truth, Braintrust as Runtime Cache**

Git is the source of truth for prompts. Braintrust is automatically kept in sync via upload scripts and enforced by pre-commit hooks and CI.

#### Source Files (Git)
Prompt source files are stored in git:
- `backend/go-screener/prompts/regenerate-filter-go.md` - Go filter code generation
- `supabase/functions/llm-proxy/prompts/analyze-signal.md` - Trading signal analysis

#### Runtime (Braintrust)
Prompts are deployed to Braintrust for use by edge functions:
- https://www.braintrust.dev/app/AI%20Trader/p/prompts
- 5-minute cache TTL
- Version history tracked automatically

#### Workflow

**Initial Setup (Get Prompts from Braintrust):**
```bash
# Download current prompts from Braintrust to git
deno run --allow-net --allow-read --allow-write --allow-env scripts/download-prompts-from-braintrust.ts

# Commit to git
git add backend/go-screener/prompts supabase/functions/llm-proxy/prompts
git commit -m "chore: add prompt source files"
```

**Updating Prompts:**
1. Edit prompt files in git directly:
   - `backend/go-screener/prompts/regenerate-filter-go.md`
   - `supabase/functions/llm-proxy/prompts/analyze-signal.md`

2. Upload to Braintrust:
   ```bash
   deno run --allow-net --allow-read --allow-env scripts/upload-all-prompts-to-braintrust.ts
   ```

3. Verify sync:
   ```bash
   deno run --allow-net --allow-read --allow-env scripts/verify-prompt-sync.ts
   ```

4. Commit changes:
   ```bash
   git add backend/go-screener/prompts supabase/functions/llm-proxy/prompts
   git commit -m "feat: update regenerate-filter-go prompt"
   ```

**Sync Enforcement:**
- **Pre-commit hook**: Blocks commits if prompt files changed but Braintrust not updated
- **GitHub Actions CI**: Verifies sync on all PRs touching prompt files
- **File hashing**: SHA-256 hashes stored in Braintrust metadata for verification

**Emergency: If Prompts Get Out of Sync**
```bash
# Option 1: Upload local changes to Braintrust
deno run --allow-net --allow-read --allow-env scripts/upload-all-prompts-to-braintrust.ts

# Option 2: Download Braintrust changes to git
deno run --allow-net --allow-read --allow-write --allow-env scripts/download-prompts-from-braintrust.ts
```

#### Rules
- NEVER edit prompts directly in Braintrust UI (use git source files)
- NEVER hardcode prompts in code
- NEVER create prompt tables in database
- ALWAYS upload to Braintrust after editing source files
- ALWAYS verify sync before committing

## Tier Access Rules
- **Anonymous**: View basic signals, charts, real-time triggers only
- **Free**: + More signals, history, favorites (NO custom signals)
- **Pro**: + Create up to 10 custom signals, notifications
- **Elite**: + Unlimited signals, AI analysis/monitoring/trading


## GitHub Flow

**All work tracked in local markdown files in `context/issues/`.**

- Local issue files will be used instead of GitHub issues.
- `context/` contains both `issues/` (issue tracking) and `docs/` (architecture docs, etc.)
- Make sure to use the https://github.com/tomkanjam account.
- Do all work on main branch unless instructed to do otherwise.
- Do frequent commits to keep the history clean and push often.

### Creating Issues
Create issue files in `context/issues/open/` with format:
- Regular issues: `YYYYMMDD-HHmmss-SSS-title.md`
- Project issues: `YYYYMMDD-HHmmss-SSS-PROJECT-title.md`

(Use milliseconds SSS to prevent collisions when creating multiple issues quickly)

```markdown
# [Title]

**Type:** [feature|bug|enhancement|docs|project]
**Initiative:** [initiative label or "none"]
**Created:** YYYY-MM-DD HH:mm:ss

## Context
[Background and motivation]

## Linked Items
- Part of: [reference to parent project if applicable]
- Related: [references to related issues]

## Sub-issues
(For PROJECT type only - remove this section for regular issues)
- [ ] `path/to/sub-issue-1.md` - Description
- [ ] `path/to/sub-issue-2.md` - Description

## Progress
[Track progress here - edit this section, don't append]

## Spec
[Implementation approach - 100 lines max]

## Completion
(Add this section when closing the issue)
**Closed:** YYYY-MM-DD HH:mm:ss
**Outcome:** [Success|Abandoned|Merged into X]
**Commits:** [list relevant commit hashes]
```

- Always create issue before starting work
- For project issues, include `PROJECT` in filename to indicate it's a parent issue
- Link to projects: Add "Part of: `path/to/project-issue.md`" in Linked Items
- Link to initiatives: Set **Initiative:** field (see Current Initiatives below)

### Implementation Flow
1. **Spec**: Deep dive into all related code - engineering review, architecture analysis, and planning. Extensive research, extremely concise output (100 lines max)
2. **Build**: Implement, autonomous testing, commit as you go
3. **Update**: Edit the Progress section in the issue file (don't append, replace)
4. **Close**: Add Completion section with close date, outcome, and commit hashes, then move file to `context/issues/closed/`

### Key Principles
- **Link everything** - Projects (file paths), initiatives (Initiative field), vision (mention in Context)
- **Autonomous** - Spec → Build → Test(use Chrome devtools for end-to-end or browser testing) → Close without asking
- **Update frequently** - After each phase, edit Progress section
- **Ask only when blocked** - Otherwise keep moving

### Quick Fixes
Small bugs/typos don't need initiative linking. Just:
- Create issue in `context/issues/open/`
- Set Initiative to "none"
- Fix it, move to closed/, done

---

## Remember:

- Check alignment before creating issues (does this serve vision/initiatives?)
- For large work, create PROJECT parent issue with sub-issues
- Edit Progress section instead of appending updates
- Move completed issues to `context/issues/closed/` with Completion section filled out


## Reference:
- Supabase Project: jtpqkbybuxbcvqeffmtf
