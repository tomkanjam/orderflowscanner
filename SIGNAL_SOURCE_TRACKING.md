# Signal Source Tracking üìä

**Date:** 2025-10-03
**Question:** Are we tracking whether a signal was generated by Fly machine or browser?

---

## Answer: Yes, partially implemented! ‚úÖ‚ö†Ô∏è

### Current Status

**‚úÖ Database Schema Ready:**
- Migration `013_add_source_to_signals.sql` exists
- Adds `source` column: 'local' (browser) or 'cloud' (Fly machine)
- Adds `machine_id` column: Reference to `cloud_machines` table

**‚úÖ Fly Machine Implementation Complete:**
- `StateSynchronizer.ts` writes `source='cloud'` for all signals
- Also includes `machine_id` reference

**‚ö†Ô∏è Browser Implementation NOT DONE:**
- Browser signals are stored **in-memory only** (not persisted to database)
- No database insertion happens in browser
- Migration needs to be applied to database

---

## Migration Details

**File:** `supabase/migrations/013_add_source_to_signals.sql`

### Schema Changes

```sql
-- Add source column to differentiate local vs cloud signals
ALTER TABLE signals ADD COLUMN IF NOT EXISTS source TEXT DEFAULT 'local';
ALTER TABLE signals ADD CONSTRAINT signals_source_check
  CHECK (source IN ('local', 'cloud'));

-- Add machine_id reference for cloud signals
ALTER TABLE signals ADD COLUMN IF NOT EXISTS machine_id UUID
  REFERENCES cloud_machines(id) ON DELETE SET NULL;

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_signals_source ON signals(source);
CREATE INDEX IF NOT EXISTS idx_signals_machine_id ON signals(machine_id);
CREATE INDEX IF NOT EXISTS idx_signals_trader_source ON signals(trader_id, source);

-- Comments for clarity
COMMENT ON COLUMN signals.source IS
  'Execution source: local (browser) or cloud (Fly.io machine)';
COMMENT ON COLUMN signals.machine_id IS
  'Reference to cloud_machines table for cloud-sourced signals';

-- Set defaults for existing signals
UPDATE signals SET source = 'local' WHERE source IS NULL;
ALTER TABLE signals ALTER COLUMN source SET NOT NULL;
```

### Migration Status

**Created:** ‚úÖ File exists
**Applied:** ‚ùì Need to check database

To apply:
```bash
# Apply via Supabase CLI
npx supabase db push

# Or apply migration file directly
psql $DATABASE_URL -f supabase/migrations/013_add_source_to_signals.sql
```

---

## Implementation Status

### ‚úÖ Fly Machine (Cloud) - COMPLETE

**File:** `server/fly-machine/services/StateSynchronizer.ts`

**Interface Definition (Lines 15-25):**
```typescript
interface PendingSignal {
  id: string;
  trader_id: string;
  symbol: string;
  price: number;
  matched_conditions: string[];
  created_at: Date;
  status: string;
  source: 'cloud'; // Always 'cloud' for Fly machine signals
  machine_id: string; // Reference to cloud_machines table (UUID)
}
```

**Signal Creation (Lines 116-126):**
```typescript
queueSignal(signal: any): void {
  this.signalQueue.push({
    id: signal.id,
    trader_id: signal.traderId,
    symbol: signal.symbol,
    price: signal.price,
    matched_conditions: signal.matchedConditions || [],
    created_at: signal.createdAt || new Date(),
    status: signal.status || 'new',
    source: 'cloud' as const, // ‚úÖ Always 'cloud' for Fly machine
    machine_id: this.machineId // ‚úÖ UUID reference to cloud_machines
  });

  this.metricsCounters.signalsCreated++;
}
```

**Database Write (Lines 203-216):**
```typescript
if (signalsToWrite.length > 0) {
  console.log(`[StateSynchronizer] Writing ${signalsToWrite.length} signals to database`);
  const { error } = await this.supabase
    .from('signals')
    .insert(signalsToWrite); // ‚úÖ Includes source='cloud' and machine_id

  if (error) {
    console.error('[StateSynchronizer] Failed to write signals:', error);
    this.signalQueue.unshift(...signalsToWrite);
  }
}
```

**What Gets Written:**
```json
{
  "id": "uuid-here",
  "trader_id": "trader-uuid",
  "symbol": "BTCUSDT",
  "price": 45000.50,
  "matched_conditions": ["RSI < 30", "Volume spike"],
  "created_at": "2025-10-03T10:30:00Z",
  "status": "new",
  "source": "cloud",        // ‚úÖ Tracked!
  "machine_id": "vyx-63eea370"  // ‚úÖ Which machine created it
}
```

### ‚ö†Ô∏è Browser - NOT IMPLEMENTED

**File:** `apps/app/src/services/signalManager.ts`

**Current Behavior:**
```typescript
export class SignalManager {
  private signals: Map<string, SignalLifecycle> = new Map();

  // Signals stored in-memory only
  // No database persistence
  // No source='local' writing
}
```

**Why No Database Write:**
The browser manages signals entirely in-memory because:
1. **Performance**: Real-time updates without database latency
2. **Temporary**: Browser signals are session-based
3. **No Persistence Need**: User can see them live in UI
4. **Database Cost**: Avoid writes for every trigger

**Current Flow:**
```
Browser Trader Match
    ‚Üì
SignalManager.createSignal()
    ‚Üì
Stored in Map (memory)
    ‚Üì
UI displays from memory
    ‚Üì
Lost on page refresh
```

**What SHOULD happen if persisting:**
```typescript
// Hypothetical implementation
async createSignal(filterResult: FilterResult): Promise<SignalLifecycle> {
  const signal = {
    id: uuidv4(),
    // ... other fields
  };

  // Write to database with source='local'
  const { error } = await supabase
    .from('signals')
    .insert({
      id: signal.id,
      trader_id: filterResult.traderId,
      symbol: filterResult.symbol,
      price: filterResult.price,
      matched_conditions: filterResult.matchedConditions,
      created_at: new Date().toISOString(),
      status: 'new',
      source: 'local',      // ‚úÖ Browser-generated
      machine_id: null      // No machine for browser signals
    });

  // Store in memory
  this.signals.set(signal.id, signal);

  return signal;
}
```

---

## Architecture Comparison

### Cloud (Fly Machine)

```
Trader Match on Fly Machine
    ‚Üì
StateSynchronizer.queueSignal()
    ‚Üì
PendingSignal: { source: 'cloud', machine_id: 'vyx-xxx' }
    ‚Üì
Batch write every 10 seconds
    ‚Üì
Database: signals table
    ‚Üì
‚úÖ Persisted with source tracking
```

### Browser (Current)

```
Trader Match in Browser
    ‚Üì
SignalManager.createSignal()
    ‚Üì
Map<string, SignalLifecycle> (memory)
    ‚Üì
UI displays signal
    ‚Üì
‚ùå Not persisted (lost on refresh)
‚ùå No source tracking in database
```

---

## Use Cases for Source Tracking

### 1. **Performance Comparison**
```sql
-- Compare signal counts by source
SELECT source, COUNT(*) as signal_count, COUNT(DISTINCT trader_id) as trader_count
FROM signals
WHERE created_at > NOW() - INTERVAL '7 days'
GROUP BY source;

-- Result:
-- source | signal_count | trader_count
-- cloud  | 1,234        | 5
-- local  | 0            | 0  (not implemented)
```

### 2. **Machine Attribution**
```sql
-- Which machine generated the most signals?
SELECT
  cm.machine_id,
  cm.region,
  COUNT(s.id) as signals_generated,
  COUNT(DISTINCT s.trader_id) as traders_active
FROM signals s
JOIN cloud_machines cm ON s.machine_id = cm.id
WHERE s.source = 'cloud'
  AND s.created_at > NOW() - INTERVAL '24 hours'
GROUP BY cm.machine_id, cm.region
ORDER BY signals_generated DESC;
```

### 3. **Debugging**
```sql
-- Find signals from specific machine
SELECT *
FROM signals
WHERE machine_id = 'vyx-63eea370'
  AND created_at > NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC;
```

### 4. **Cloud vs Browser Analysis**
```sql
-- Compare profitability by source (future)
SELECT
  s.source,
  COUNT(*) as total_signals,
  COUNT(t.id) as trades_executed,
  AVG(t.profit_loss) as avg_profit
FROM signals s
LEFT JOIN trades t ON s.id = t.signal_id
GROUP BY s.source;
```

---

## Next Steps

### If Browser Signals Should Be Persisted:

**1. Apply Migration:**
```bash
npx supabase db push
```

**2. Update SignalManager:**
```typescript
// In signalManager.ts
import { supabase } from '../config/supabase';

async createSignal(filterResult: FilterResult): Promise<SignalLifecycle> {
  const signal = {
    id: uuidv4(),
    traderId: filterResult.traderId,
    // ... other fields
  };

  // Persist to database with source='local'
  try {
    await supabase.from('signals').insert({
      id: signal.id,
      trader_id: signal.traderId,
      symbol: signal.symbol,
      price: signal.price,
      matched_conditions: signal.matchedConditions,
      created_at: new Date().toISOString(),
      status: 'new',
      source: 'local',  // ‚úÖ Browser source
      machine_id: null  // No machine for browser
    });
  } catch (error) {
    console.error('[SignalManager] Failed to persist signal:', error);
    // Continue anyway - keep in memory
  }

  // Store in memory
  this.signals.set(signal.id, signal);
  return signal;
}
```

**3. Update TypeScript Types:**
```typescript
// In types.ts or interfaces.ts
export interface Signal {
  id: string;
  trader_id: string;
  symbol: string;
  price: number;
  matched_conditions: string[];
  created_at: Date;
  status: SignalStatus;
  source: 'local' | 'cloud';  // ‚úÖ Add source field
  machine_id: string | null;   // ‚úÖ Add machine reference
}
```

### If Browser Signals Should Stay In-Memory:

**That's fine!** The architecture makes sense:
- **Cloud signals** = Persistent, long-running, need tracking ‚Üí Database
- **Browser signals** = Temporary, session-based, UI-only ‚Üí Memory

You can still query cloud signals by source:
```sql
SELECT * FROM signals WHERE source = 'cloud';
```

---

## Current Reality

**What's Working:**
- ‚úÖ Migration exists and is ready
- ‚úÖ Fly machine writes `source='cloud'` to database
- ‚úÖ Cloud signals are fully tracked with machine attribution
- ‚úÖ Indexes in place for efficient queries

**What's Missing:**
- ‚ö†Ô∏è Migration not yet applied to database
- ‚ö†Ô∏è Browser doesn't persist signals to database
- ‚ö†Ô∏è No `source='local'` signals in production

**Decision Needed:**
Should browser signals be persisted?

**Reasons to persist:**
- Historical record of all signals
- Compare browser vs cloud performance
- User can see signal history across sessions
- Better debugging and analytics

**Reasons to keep in-memory:**
- Lower database costs
- Faster UI updates
- Browser signals are temporary/exploratory
- Users mainly care about cloud signals

---

## Summary

**Question:** Are we tracking signal source?

**Answer:**
- **Cloud (Fly):** ‚úÖ Yes - fully tracked with `source='cloud'` and `machine_id`
- **Browser:** ‚ùå No - signals stored in-memory only, not persisted
- **Migration:** ‚úÖ Ready but needs to be applied to database
- **Architecture:** Makes sense as-is, but could enhance with browser persistence

**To enable full tracking:**
1. Apply migration 013
2. Update SignalManager to persist browser signals with `source='local'`
3. Update TypeScript interfaces

**Or keep as-is:**
- Cloud signals tracked ‚úÖ
- Browser signals ephemeral ‚úÖ
- Query cloud signals: `WHERE source='cloud'` ‚úÖ
