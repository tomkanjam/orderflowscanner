package storage

import (
	"context"
	"time"
)

// Storage interface abstracts data persistence layer
// Implementations: SQLite (local), Supabase (cloud)
type Storage interface {
	// Traders
	GetActiveTraders(ctx context.Context, userID string) ([]Trader, error)
	GetTrader(ctx context.Context, traderID string) (*Trader, error)
	CreateTrader(ctx context.Context, trader *Trader) error
	UpdateTrader(ctx context.Context, trader *Trader) error
	DeleteTrader(ctx context.Context, traderID string) error

	// Signals
	GetSignals(ctx context.Context, traderID string, limit int) ([]Signal, error)
	CreateSignal(ctx context.Context, signal *Signal) error
	UpdateSignal(ctx context.Context, signal *Signal) error

	// Positions
	GetOpenPositions(ctx context.Context, userID string) ([]Position, error)
	GetPosition(ctx context.Context, positionID string) (*Position, error)
	CreatePosition(ctx context.Context, pos *Position) error
	UpdatePosition(ctx context.Context, pos *Position) error
	ClosePosition(ctx context.Context, positionID string) error

	// Machine heartbeat (cloud only)
	UpdateHeartbeat(ctx context.Context, machineID string) error

	// Close connection
	Close() error
}

// Trader represents an AI trading strategy
type Trader struct {
	ID                 string    `json:"id"`
	UserID             string    `json:"user_id"`
	Name               string    `json:"name"`
	Description        string    `json:"description"`
	Symbols            []string  `json:"symbols"`
	Timeframes         []string  `json:"timeframes"`
	CheckInterval      string    `json:"check_interval"`
	SignalCode         string    `json:"signal_code"`
	ReanalysisInterval string    `json:"reanalysis_interval"`
	Status             string    `json:"status"` // active, paused, stopped
	CreatedAt          time.Time `json:"created_at"`
	UpdatedAt          time.Time `json:"updated_at"`
}

// Signal represents a trading signal generated by a trader
type Signal struct {
	ID           string                 `json:"id"`
	TraderID     string                 `json:"trader_id"`
	Symbol       string                 `json:"symbol"`
	Timeframe    string                 `json:"timeframe"`
	SignalType   string                 `json:"signal_type"` // entry, exit, scale
	Status       string                 `json:"status"`      // pending, analyzing, executed, cancelled
	TriggerPrice float64                `json:"trigger_price"`
	TargetPrice  float64                `json:"target_price"`
	StopLoss     float64                `json:"stop_loss"`
	Confidence   int                    `json:"confidence"`
	Reasoning    string                 `json:"reasoning"`
	Metadata     map[string]interface{} `json:"metadata"`
	CreatedAt    time.Time              `json:"created_at"`
	UpdatedAt    time.Time              `json:"updated_at"`
}

// Position represents an open trading position
type Position struct {
	ID           string     `json:"id"`
	UserID       string     `json:"user_id"`
	TraderID     string     `json:"trader_id"`
	SignalID     string     `json:"signal_id"`
	Symbol       string     `json:"symbol"`
	Side         string     `json:"side"` // LONG, SHORT
	EntryPrice   float64    `json:"entry_price"`
	CurrentPrice float64    `json:"current_price"`
	Size         float64    `json:"size"`
	StopLoss     float64    `json:"stop_loss"`
	TakeProfit   float64    `json:"take_profit"`
	PNL          float64    `json:"pnl"`
	PNLPct       float64    `json:"pnl_pct"`
	Status       string     `json:"status"` // open, closed, stopped
	CreatedAt    time.Time  `json:"created_at"`
	UpdatedAt    time.Time  `json:"updated_at"`
	ClosedAt     *time.Time `json:"closed_at,omitempty"`
}
