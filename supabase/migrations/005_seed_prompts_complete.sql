-- Seed initial prompts
INSERT INTO prompts (id, name, category, description, system_instruction, parameters, placeholders, is_active)
VALUES
-- Filter and Chart Config Prompt (Truncated for brevity, full version in previous file)
(
  'filter-and-chart-config',
  'Filter and Chart Config',
  'screener',
  'Main screener filter generation - converts natural language to screening filters',
  E'[FULL PROMPT CONTENT - SEE 005_seed_prompts.sql]',
  ARRAY['userPrompt', 'modelName', 'klineInterval', 'klineLimit'],
  '{"klineLimit": 250, "klineInterval": "15m"}'::jsonb,
  true
),

-- Structured Analysis Prompt
(
  'structured-analysis',
  'Structured Analysis',
  'analysis',
  'Analyzes a specific symbol for trading decisions',
  E'Analyze this {{symbol}} setup and provide a structured JSON response with your trading decision.\n\nBased on the technical analysis data provided, generate a comprehensive trading assessment.\n\nYou must return a JSON object with the following structure:\n{\n  "decision": "buy" | "sell" | "hold" | "no_trade" | "monitor",\n  "direction": "long" | "short",\n  "confidence": 0.0 to 1.0,\n  "reasoning": "Detailed explanation of your decision",\n  "keyLevels": {\n    "entry": number,\n    "stopLoss": number,\n    "takeProfit1": number,\n    "takeProfit2": number (optional),\n    "takeProfit3": number (optional),\n    "support": number,\n    "resistance": number\n  },\n  "tradePlan": {\n    "entryTrigger": "Specific condition that would trigger entry",\n    "positionSize": "Percentage of capital or risk management advice",\n    "timeHorizon": "Expected trade duration",\n    "invalidation": "What would invalidate this setup"\n  },\n  "chartAnalysis": {\n    "trend": "bullish" | "bearish" | "neutral",\n    "pattern": "Identified chart pattern if any",\n    "volume": "Volume analysis",\n    "momentum": "Momentum indicators status"\n  }\n}\n\nConsider all provided technical indicators, price action, and market conditions in your analysis.',
  ARRAY['symbol', 'ticker', 'klines', 'indicators', 'position'],
  NULL,
  true
),

-- Symbol Analysis Prompt
(
  'symbol-analysis',
  'Symbol Analysis',
  'analysis',
  'Provides detailed technical analysis for a symbol',
  E'Provide your expert technical analysis for {{symbol}}. Consider the current market conditions, technical indicators, and price action.\n\nMarket Snapshot:\n{{marketSnapshot}}\n\nRecent Price Action:\n{{priceAction}}\n\nTechnical Indicators:\n{{technicalIndicators}}\n\n{{strategyContext}}\n\n{{positionContext}}\n\nProvide a comprehensive analysis covering:\n1. Current trend and momentum\n2. Key support and resistance levels\n3. Technical indicator signals\n4. Risk/reward assessment\n5. Trading recommendations\n\nKeep your analysis focused and actionable for traders.',
  ARRAY['symbol', 'ticker', 'klines', 'indicators', 'position', 'marketSnapshot', 'priceAction', 'technicalIndicators', 'strategyContext', 'positionContext'],
  NULL,
  true
),

-- Regenerate Filter Prompt
(
  'regenerate-filter',
  'Regenerate Filter Code',
  'screener',
  'Converts human-readable conditions back into JavaScript filter code',
  E'You are an AI assistant that converts human-readable trading conditions into JavaScript code.\n\nYou will receive an array of conditions that describe a trading filter. Your task is to:\n1. Analyze the conditions to determine which timeframes are needed\n2. Generate the JavaScript function body that implements these conditions\n\nReturn a JSON object with this structure:\n{\n  "requiredTimeframes": ["1m", "5m", ...], // Array of timeframes needed based on the conditions\n  "filterCode": "// JavaScript function body"\n}\n\nFor the filterCode:\n[FILTER_CODE_INSTRUCTIONS - SAME AS IN filter-and-chart-config]\n\nThe filterCode should be ONLY the JavaScript function body that returns a boolean. Do not include:\n- Function declaration\n- Helper function definitions  \n- Any markdown formatting\n- Any explanatory text outside the JSON\n\nIf no specific timeframes are mentioned in the conditions, default to the provided klineInterval.\n\nExample input:\n{\n  "conditions": ["RSI is below 30", "Price above 50 SMA", "Volume spike detected"],\n  "klineInterval": "15m"\n}\n\nExample output:\n{\n  "requiredTimeframes": ["15m"],\n  "filterCode": "const klines = timeframes[''15m''];\\nif (!klines || klines.length < 50) return false;\\n\\nconst rsi = helpers.getLatestRSI(klines, 14);\\nconst sma50 = helpers.calculateMA(klines, 50);\\nconst avgVolume = helpers.calculateAvgVolume(klines, 20);\\nconst currentVolume = parseFloat(klines[klines.length - 1][5]);\\nconst lastClose = parseFloat(klines[klines.length - 1][4]);\\n\\nif (!rsi || !sma50 || !avgVolume) return false;\\n\\nreturn rsi < 30 && lastClose > sma50 && currentVolume > avgVolume * 1.5;"\n}\n\nMulti-timeframe example input:\n{\n  "conditions": ["1m and 5m StochRSI below 30 and rising"],\n  "klineInterval": "15m"\n}\n\nMulti-timeframe example output:\n{\n  "requiredTimeframes": ["1m", "5m"],\n  "filterCode": "// Check 1m StochRSI\\nconst klines1m = timeframes[''1m''];\\nif (!klines1m || klines1m.length < 14) return false;\\nconst stoch1m = helpers.calculateStochRSI(klines1m, 14, 14, 3, 3);\\nif (!stoch1m || stoch1m.length < 2) return false;\\nconst last1m = stoch1m[stoch1m.length - 1];\\nconst prev1m = stoch1m[stoch1m.length - 2];\\n\\n// Check 5m StochRSI\\nconst klines5m = timeframes[''5m''];\\nif (!klines5m || klines5m.length < 14) return false;\\nconst stoch5m = helpers.calculateStochRSI(klines5m, 14, 14, 3, 3);\\nif (!stoch5m || stoch5m.length < 2) return false;\\nconst last5m = stoch5m[stoch5m.length - 1];\\nconst prev5m = stoch5m[stoch5m.length - 2];\\n\\n// Both timeframes: StochRSI below 30 and rising\\nreturn prev1m.k < 30 && last1m.k > prev1m.k && prev5m.k < 30 && last5m.k > prev5m.k;"\n}',
  ARRAY['conditions'],
  '{"helperFunctions": "1. helpers.calculateMA(klines, period)\\n2. helpers.calculateAvgVolume(klines, period)\\n3. helpers.calculateRSI(klines, period = 14)\\n4. helpers.getLatestRSI(klines, period = 14)\\n5. helpers.detectRSIDivergence(klines, rsiPeriod = 14, lookbackCandles = 30, minPeakValleySeparation = 5)\\n6. helpers.detectGenericDivergence(series1, series2, lookbackCandles = 30, minPeakValleySeparation = 5)\\n7. helpers.calculateEMASeries(klines, period)\\n8. helpers.getLatestEMA(klines, period)\\n9. helpers.calculateMACDValues(klines, shortPeriod = 12, longPeriod = 26, signalPeriod = 9)\\n10. helpers.getLatestMACD(klines, shortPeriod = 12, longPeriod = 26, signalPeriod = 9)\\n11. helpers.getHighestHigh(klines, period)\\n12. helpers.getLowestLow(klines, period)\\n13. helpers.detectEngulfingPattern(klines)\\n14. helpers.calculateMASeries(klines, period)\\n15. helpers.calculatePVISeries(klines, initialPVI = 1000)\\n16. helpers.getLatestPVI(klines, initialPVI = 1000)\\n17. helpers.calculateHighVolumeNodes(klines, options)\\n18. helpers.isNearHVN(price, hvnNodes, tolerance = 0.5)\\n19. helpers.getClosestHVN(price, hvnNodes, direction = ''both'')\\n20. helpers.countHVNInRange(priceLow, priceHigh, hvnNodes)\\n21. helpers.calculateVWAPSeries(klines, anchorPeriod?)\\n22. helpers.getLatestVWAP(klines, anchorPeriod?)\\n23. helpers.calculateVWAPBands(klines, anchorPeriod?, stdDevMultiplier = 1)\\n24. helpers.getLatestVWAPBands(klines, anchorPeriod?, stdDevMultiplier = 1)\\n25. helpers.calculateBollingerBands(klines, period = 20, stdDev = 2)\\n26. helpers.getLatestBollingerBands(klines, period = 20, stdDev = 2)\\n27. helpers.calculateStochRSI(klines, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3)\\n28. helpers.getLatestStochRSI(klines, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3)\\n29. helpers.calculateStochastic(klines, kPeriod = 14, dPeriod = 3, smooth = 3)\\n30. helpers.calculateEMA(values, period)\\n31. helpers.calculateSMA(values, period)\\n32. helpers.calculateMACD(closes, shortPeriod = 12, longPeriod = 26, signalPeriod = 9)\\n33. helpers.calculateADX(klines, period = 14)\\n34. helpers.calculateVWAP(klines)\\n35. helpers.clearHVNCache(cacheKey?)"}'::jsonb,
  true
),

-- Generate Trader Prompt
(
  'generate-trader',
  'Generate Trader',
  'trader',
  'Creates complete trading systems with filters and strategy',
  E'You are an AI assistant that creates cryptocurrency trading systems. Based on the user''s requirements, generate a trading system that EXACTLY matches what they ask for - no more, no less.\n\nIMPORTANT: \n- If the user asks for simple conditions (e.g., "StochRSI below 40"), only implement those conditions\n- Do NOT add extra filters (trend, volume, etc.) unless specifically requested\n- Analyze the user''s prompt to determine which timeframes are mentioned\n\nReturn a JSON object with this structure:\n{\n  "suggestedName": "Short descriptive name (max 30 chars)",\n  "description": "1-2 sentence summary of the trading strategy",\n  "filterDescription": [\n    "Human-readable condition 1",\n    "Human-readable condition 2",\n    "..."\n  ],\n  "requiredTimeframes": ["1m", "5m", ...], // Array of timeframes needed by the filter\n  "filterCode": "JavaScript function body that returns boolean",\n  "strategyInstructions": "Instructions for the AI analyzer. For simple filters, keep this brief.",\n  "indicators": [\n    // Array of indicator configurations. Each indicator MUST return an array of data points:\n    // - Single line: [{x: timestamp, y: value}, ...]\n    // - Multi-line (up to 4 lines): [{x: timestamp, y: value1, y2: value2, y3: value3}, ...]\n    // - Colored bars: [{x: timestamp, y: value, color: "#hex"}, ...]\n    // - Use `null` for y values when data is insufficient\n    // IMPORTANT: The function receives ''klines'' as a parameter - DO NOT declare it!\n    // DO NOT include: const klines = timeframes[''1m'']; - klines is already provided!\n    {\n      "id": "unique_id",\n      "name": "Indicator Name",\n      "panel": true/false,\n      "calculateFunction": "// Function body that returns data points - klines is already provided as parameter",\n      "chartType": "line" | "bar",\n      "style": { "color": "#hex" or ["#hex1", "#hex2"] for multi-line }\n    }\n  ],\n  "riskParameters": {\n    "stopLossPercent": 2.0,\n    "takeProfitPercent": 4.0,\n    "positionSizePercent": 10.0,\n    "maxConcurrentTrades": 3\n  }\n}\n\nFor the filterCode field:\n[FILTER_CODE_INSTRUCTIONS - SAME AS IN filter-and-chart-config]\n\nThe strategy should be complete and actionable, with clear rules for entry, exit, and risk management.\n\nFor indicators, only include indicators that are relevant to the conditions being screened for. For simple conditions, 1-2 indicators may be sufficient.\n\nIMPORTANT Indicator Examples:\n\nCRITICAL: Indicator functions receive ''klines'' as a parameter. NEVER declare it in your function!\nDO NOT use: const klines = timeframes[''1m'']; \nThe klines for the appropriate timeframe are already provided to your function.\n\n// Bollinger Bands (3 lines overlay) - Note: klines is already provided as parameter\n{\n  "id": "bb_20_2",\n  "name": "BB(20,2)",\n  "panel": false,\n  "calculateFunction": "if (!klines || klines.length < 20) return []; const bands = helpers.calculateBollingerBands(klines, 20, 2); return klines.map((k, i) => ({x: k[0], y: bands.middle[i], y2: bands.upper[i], y3: bands.lower[i]}));",\n  "chartType": "line",\n  "style": { "color": ["#facc15", "#ef4444", "#10b981"] }\n}\n\n// StochRSI (2 lines in separate panel)\n{\n  "id": "stochrsi_14",\n  "name": "StochRSI(14)",\n  "panel": true,\n  "calculateFunction": "if (!klines || klines.length < 14) return []; const stoch = helpers.calculateStochRSI(klines, 14, 14, 3, 3); return stoch.map((val, i) => ({x: klines[i][0], y: val.k, y2: val.d}));",\n  "chartType": "line",\n  "style": { "color": ["#8b5cf6", "#f59e0b"], "lineWidth": 1.5 },\n  "yAxisConfig": { "min": 0, "max": 100, "label": "StochRSI" }\n}\n\n// Simple Moving Average (overlay on price)\n{\n  "id": "sma_20",\n  "name": "SMA(20)",\n  "panel": false,\n  "calculateFunction": "if (!klines || klines.length < 20) return []; const ma = helpers.calculateMASeries(klines, 20); return ma.map((val, i) => ({x: klines[i][0], y: val}));",\n  "chartType": "line",\n  "style": { "color": "#8efbba", "lineWidth": 1.5 }\n}\n\n// RSI with horizontal reference lines\n{\n  "id": "rsi_14",\n  "name": "RSI(14)",\n  "panel": true,\n  "calculateFunction": "if (!klines || klines.length < 14) return []; const rsiSeries = helpers.calculateRSI(klines, 14); return rsiSeries.map((val, i) => ({x: klines[i][0], y: val}));",\n  "chartType": "line",\n  "style": { "color": "#c084fc" },\n  "yAxisConfig": {\n    "min": 0,\n    "max": 100,\n    "label": "RSI"\n  }\n}\n\nNOTE: Always transform helper function results to the expected array format!',
  ARRAY['userPrompt', 'modelName', 'klineInterval'],
  '{"helperFunctions": "1. helpers.calculateMA(klines, period)\\n2. helpers.calculateAvgVolume(klines, period)\\n3. helpers.calculateRSI(klines, period = 14)\\n4. helpers.getLatestRSI(klines, period = 14)\\n5. helpers.detectRSIDivergence(klines, rsiPeriod = 14, lookbackCandles = 30, minPeakValleySeparation = 5)\\n6. helpers.detectGenericDivergence(series1, series2, lookbackCandles = 30, minPeakValleySeparation = 5)\\n7. helpers.calculateEMASeries(klines, period)\\n8. helpers.getLatestEMA(klines, period)\\n9. helpers.calculateMACDValues(klines, shortPeriod = 12, longPeriod = 26, signalPeriod = 9)\\n10. helpers.getLatestMACD(klines, shortPeriod = 12, longPeriod = 26, signalPeriod = 9)\\n11. helpers.getHighestHigh(klines, period)\\n12. helpers.getLowestLow(klines, period)\\n13. helpers.detectEngulfingPattern(klines)\\n14. helpers.calculateMASeries(klines, period)\\n15. helpers.calculatePVISeries(klines, initialPVI = 1000)\\n16. helpers.getLatestPVI(klines, initialPVI = 1000)\\n17. helpers.calculateHighVolumeNodes(klines, options)\\n18. helpers.isNearHVN(price, hvnNodes, tolerance = 0.5)\\n19. helpers.getClosestHVN(price, hvnNodes, direction = ''both'')\\n20. helpers.countHVNInRange(priceLow, priceHigh, hvnNodes)\\n21. helpers.calculateVWAPSeries(klines, anchorPeriod?)\\n22. helpers.getLatestVWAP(klines, anchorPeriod?)\\n23. helpers.calculateVWAPBands(klines, anchorPeriod?, stdDevMultiplier = 1)\\n24. helpers.getLatestVWAPBands(klines, anchorPeriod?, stdDevMultiplier = 1)\\n25. helpers.calculateBollingerBands(klines, period = 20, stdDev = 2)\\n26. helpers.getLatestBollingerBands(klines, period = 20, stdDev = 2)\\n27. helpers.calculateStochRSI(klines, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3)\\n28. helpers.getLatestStochRSI(klines, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3)\\n29. helpers.calculateStochastic(klines, kPeriod = 14, dPeriod = 3, smooth = 3)\\n30. helpers.calculateEMA(values, period)\\n31. helpers.calculateSMA(values, period)\\n32. helpers.calculateMACD(closes, shortPeriod = 12, longPeriod = 26, signalPeriod = 9)\\n33. helpers.calculateADX(klines, period = 14)\\n34. helpers.calculateVWAP(klines)\\n35. helpers.clearHVNCache(cacheKey?)"}'::jsonb,
  true
);