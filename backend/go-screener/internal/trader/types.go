package trader

import (
	"context"
	"sync"
	"time"
)

// TraderState represents the lifecycle state of a trader
type TraderState string

const (
	// StateStopped indicates the trader is not running
	StateStopped TraderState = "stopped"

	// StateStarting indicates the trader is initializing
	StateStarting TraderState = "starting"

	// StateRunning indicates the trader is actively screening
	StateRunning TraderState = "running"

	// StateStopping indicates the trader is shutting down gracefully
	StateStopping TraderState = "stopping"

	// StateError indicates the trader encountered a fatal error
	StateError TraderState = "error"
)

// String returns the string representation of the state
func (s TraderState) String() string {
	return string(s)
}

// IsValid checks if the state is a valid trader state
func (s TraderState) IsValid() bool {
	switch s {
	case StateStopped, StateStarting, StateRunning, StateStopping, StateError:
		return true
	default:
		return false
	}
}

// TraderConfig holds the configuration for a trader
type TraderConfig struct {
	// Filter configuration
	FilterCode        string              `json:"filter_code"`
	ScreeningInterval time.Duration       `json:"screening_interval"`
	Symbols           []string            `json:"symbols"`
	Timeframes        []string            `json:"timeframes"`
	Indicators        []IndicatorConfig   `json:"indicators"`

	// Resource limits
	MaxSignalsPerRun  int                 `json:"max_signals_per_run"`
	TimeoutPerRun     time.Duration       `json:"timeout_per_run"`
}

// IndicatorConfig defines a technical indicator for the trader
type IndicatorConfig struct {
	Type       string                 `json:"type"`        // "sma", "rsi", "macd", etc.
	Parameters map[string]interface{} `json:"parameters"`  // indicator-specific params
}

// Trader represents a running trading strategy instance
type Trader struct {
	// Immutable fields (set at creation)
	ID          string        `json:"id"`
	UserID      string        `json:"user_id"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
	Config      *TraderConfig `json:"config"`

	// Mutable state (protected by mutex)
	state       TraderState   `json:"state"`
	lastError   error         `json:"last_error,omitempty"`
	startedAt   time.Time     `json:"started_at,omitempty"`
	stoppedAt   time.Time     `json:"stopped_at,omitempty"`
	signalCount int64         `json:"signal_count"`
	lastRunAt   time.Time     `json:"last_run_at,omitempty"`

	// Runtime context (for cancellation)
	ctx    context.Context
	cancel context.CancelFunc

	// Mutex for thread-safe state access
	mu sync.RWMutex
}

// TraderStatus represents the current status of a trader (for API responses)
type TraderStatus struct {
	ID          string      `json:"id"`
	UserID      string      `json:"user_id"`
	Name        string      `json:"name"`
	State       TraderState `json:"state"`
	LastError   string      `json:"last_error,omitempty"`
	StartedAt   *time.Time  `json:"started_at,omitempty"`
	StoppedAt   *time.Time  `json:"stopped_at,omitempty"`
	SignalCount int64       `json:"signal_count"`
	LastRunAt   *time.Time  `json:"last_run_at,omitempty"`
	Uptime      int64       `json:"uptime_seconds,omitempty"` // seconds since started
}

// Signal represents a trading signal generated by a trader
type Signal struct {
	ID            string                 `json:"id"`
	TraderID      string                 `json:"trader_id"`
	UserID        string                 `json:"user_id"`
	Symbol        string                 `json:"symbol"`
	Interval      string                 `json:"interval"`           // The interval that triggered this signal
	TriggeredAt   time.Time              `json:"triggered_at"`
	Price         float64                `json:"price"`
	Volume        float64                `json:"volume"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`       // Additional data from filter
	IndicatorData map[string]interface{} `json:"indicator_data,omitempty"` // Calculated indicator values for visualization
	CreatedAt     time.Time              `json:"created_at"`
}

// NewTrader creates a new Trader instance
func NewTrader(id, userID, name, description string, config *TraderConfig) *Trader {
	ctx, cancel := context.WithCancel(context.Background())

	return &Trader{
		ID:          id,
		UserID:      userID,
		Name:        name,
		Description: description,
		Config:      config,
		state:       StateStopped,
		ctx:         ctx,
		cancel:      cancel,
	}
}

// GetState returns the current state (thread-safe)
func (t *Trader) GetState() TraderState {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.state
}

// GetStatus returns the current trader status (thread-safe)
func (t *Trader) GetStatus() TraderStatus {
	t.mu.RLock()
	defer t.mu.RUnlock()

	status := TraderStatus{
		ID:          t.ID,
		UserID:      t.UserID,
		Name:        t.Name,
		State:       t.state,
		SignalCount: t.signalCount,
	}

	if t.lastError != nil {
		status.LastError = t.lastError.Error()
	}

	if !t.startedAt.IsZero() {
		status.StartedAt = &t.startedAt
		if t.state == StateRunning {
			uptime := int64(time.Since(t.startedAt).Seconds())
			status.Uptime = uptime
		}
	}

	if !t.stoppedAt.IsZero() {
		status.StoppedAt = &t.stoppedAt
	}

	if !t.lastRunAt.IsZero() {
		status.LastRunAt = &t.lastRunAt
	}

	return status
}

// IncrementSignalCount increments the signal count (thread-safe)
func (t *Trader) IncrementSignalCount(delta int64) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.signalCount += delta
}

// UpdateLastRunAt updates the last run timestamp (thread-safe)
func (t *Trader) UpdateLastRunAt() {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.lastRunAt = time.Now()
}

// Context returns the trader's cancellation context
func (t *Trader) Context() context.Context {
	return t.ctx
}

// Cancel cancels the trader's context (stops execution)
func (t *Trader) Cancel() {
	if t.cancel != nil {
		t.cancel()
	}
}
