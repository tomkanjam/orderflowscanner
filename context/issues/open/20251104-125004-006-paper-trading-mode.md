# Implement Paper Trading Execution Engine

**Type:** feature
**Initiative:** End-to-end trader workflow implementation
**Created:** 2025-11-04 12:50:04

## Context

**PHASE 1 CORE COMPONENT** - Build the complete trade execution engine using simulated orders. This is NOT just a testing feature - it's the PRIMARY execution system for Phase 1.

**Why paper trading first:**
- Validate entire workflow without risk
- Prove architecture before real money
- Test position management integration
- Catch all bugs in safe environment
- Users can validate strategies risk-free

**Phase 2 strategy:** CCXT will be a drop-in replacement for the paper executor - same interfaces, same workflow, different execution.

## Linked Items

- Part of: `context/issues/open/20251104-125004-000-PROJECT-trade-execution-infrastructure.md` (Phase 1)
- Depends on:
  - `context/issues/open/20251104-125004-001-positions-schema-and-lifecycle.md`
  - `context/issues/open/20251104-125004-004-risk-management-system.md`
- Blocks:
  - `context/issues/open/20251104-125004-007-pnl-calculation-engine.md`
  - `context/issues/open/20251104-125004-009-paper-trading-testing.md`

## Progress

**Status:** Not started

## Spec

### Implementation Strategy

**Toggle in trader config:**
```typescript
interface Trader {
  // ... existing fields
  paper_trade_mode: boolean
  paper_trade_balance: number // Starting virtual balance
}
```

**Database flag:**
```sql
ALTER TABLE positions ADD COLUMN is_paper_trade BOOLEAN DEFAULT false;
ALTER TABLE orders ADD COLUMN is_paper_trade BOOLEAN DEFAULT false;
```

### Paper Trade Execution

**In OrderExecutor:**
```go
func (e *Executor) submitOrder(ctx context.Context, position *Position, size *PositionSize, apiKey, secret string) error {
    if e.config.PaperTradeMode || position.IsPaperTrade {
        return e.simulatePaperOrder(ctx, position, size)
    }

    // Real order via CCXT
    // ...
}

func (e *Executor) simulatePaperOrder(ctx context.Context, position *Position, size *PositionSize) error {
    // Get current market price (real data)
    ticker, err := e.binance.GetTicker(ctx, position.Symbol)
    if err != nil {
        return err
    }

    // Simulate slippage (random 0-0.1%)
    slippage := rand.Float64() * 0.001
    fillPrice := ticker.LastPrice * (1 + slippage)

    // Simulate fill delay (100-500ms)
    time.Sleep(time.Millisecond * time.Duration(100+rand.Intn(400)))

    // Create paper order record
    order := &Order{
        PositionID:      position.ID,
        UserID:          position.UserID,
        Symbol:          position.Symbol,
        Side:            "buy",
        Type:            "market",
        Quantity:        size.Quantity,
        FilledQuantity:  size.Quantity,
        AvgFillPrice:    fillPrice,
        TotalValue:      size.Quantity * fillPrice,
        Fees:            size.Quantity * fillPrice * 0.001, // Binance fee
        Status:          "filled",
        IsPaperTrade:    true,
        BinanceOrderID:  fmt.Sprintf("PAPER-%d", time.Now().Unix()),
        SubmittedAt:     time.Now(),
        FilledAt:        time.Now(),
    }

    if err := e.supabase.CreateOrder(ctx, order); err != nil {
        return err
    }

    // Update position
    position.Status = "open"
    position.EntryPrice = order.AvgFillPrice
    position.EntryQuantity = order.FilledQuantity
    position.EntryValue = order.TotalValue
    position.FeesPaid = order.Fees
    position.EntryTime = order.FilledAt

    return e.supabase.UpdatePosition(ctx, position)
}
```

### Paper Balance Tracking

**Database table:**
```sql
CREATE TABLE paper_balances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  trader_id UUID REFERENCES traders(id),

  -- Balance
  initial_balance DECIMAL(20, 8) DEFAULT 10000,
  current_balance DECIMAL(20, 8),
  total_pnl DECIMAL(20, 8) DEFAULT 0,

  -- Stats
  total_trades INT DEFAULT 0,
  winning_trades INT DEFAULT 0,
  losing_trades INT DEFAULT 0,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(user_id, trader_id)
);
```

**Update balance on position close:**
```go
func (e *Executor) closePaperPosition(ctx context.Context, position *Position) error {
    // Get current price
    ticker, err := e.binance.GetTicker(ctx, position.Symbol)
    if err != nil {
        return err
    }

    // Calculate PnL
    exitValue := position.EntryQuantity * ticker.LastPrice
    pnl := exitValue - position.EntryValue - position.FeesPaid
    pnlPercent := (pnl / position.EntryValue) * 100

    // Update position
    position.Status = "closed"
    position.ExitPrice = ticker.LastPrice
    position.ExitQuantity = position.EntryQuantity
    position.ExitValue = exitValue
    position.ExitTime = time.Now()
    position.RealizedPnL = pnl
    position.RealizedPnLPercent = pnlPercent

    if err := e.supabase.UpdatePosition(ctx, position); err != nil {
        return err
    }

    // Update paper balance
    return e.supabase.UpdatePaperBalance(ctx, position.UserID, position.TraderID, pnl)
}
```

### UI Indicator

Show clear indicator that user is in paper trade mode:

```tsx
{trader.paper_trade_mode && (
  <Alert variant="info">
    üìù Paper Trading Mode - No real money at risk
    <br />
    Virtual Balance: ${paperBalance.current_balance.toFixed(2)}
  </Alert>
)}
```

### Convert to Real Trading

**Workflow:**
1. User validates strategy in paper mode
2. Achieves target win rate / PnL
3. Clicks "Switch to Live Trading"
4. System requires:
   - API keys configured
   - Risk limits set
   - Confirmation dialog (understand risks)
5. Update `trader.paper_trade_mode = false`
6. All future signals execute with real money

### Testing

**Unit tests:**
- Paper orders create correct records
- PnL calculated accurately
- Balance updates correctly
- Slippage simulation realistic

**Integration tests:**
- Full workflow: signal ‚Üí paper position ‚Üí paper close
- Multiple paper positions don't interfere
- Paper balance isolated per trader
- Real and paper modes can't mix

### Success Criteria

- [ ] Paper mode executes without API keys
- [ ] Paper orders use real market data for pricing
- [ ] Paper PnL calculated accurately
- [ ] Paper balance tracked separately
- [ ] UI clearly indicates paper mode
- [ ] Can switch to live trading after validation
- [ ] Paper trades stored with `is_paper_trade=true`
- [ ] Paper mode works identically to live (except no real orders)

### Effort Estimate

**3-4 days**
